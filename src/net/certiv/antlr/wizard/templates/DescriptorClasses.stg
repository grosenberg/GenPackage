delimiters "%", "%"

IDescriptorClass(packageName) ::= <<
package %packageName%.converter;

public interface IDescriptor {

	public void initialize();

	public Value process();

	public Value process(String property);

	public String toString();
}
>>

BaseDescriptorClass(packageName, grammarName) ::= <<
package %packageName%.converter;

import java.util.ArrayList;
import java.util.List;

import %packageName%.symbol.Symbol;
import %packageName%.types.StmtType;
import %packageName%.types.ValueType;
import %packageName%.util.Log;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ErrorNodeImpl;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNodeImpl;

public abstract class BaseDescriptor implements IDescriptor {

	public static final String SP	= " ";
	public static final String RN	= "\r\n";
	public static final String DOT	= ".";
	public static final String STAR	= "*";
	public static final String HASH	= "#";

	// reference to shared data
	public PhaseState state;
	
	// local non-shared data
	public ParserRuleContext ctx; // current context
	public List<ElementAssoc> assocElement; // elements of context

	public Value value; // the resolved value of this node
	public ValueType type; // generalized type of this node
	public boolean resolved = false; // whether this and all child nodes have been resolved

	public boolean collectComments = false;
	public String commentLeft;
	public String commentRight;
	
	public class ElementAssoc {
		public StmtType type;
		public int index;
		public Token token;
		public ParseTree tree;

		public ElementAssoc(StmtType type, Token token, ParseTree tree) {
			super();
			this.type = type;
			this.index = token.getTokenIndex();
			this.token = token;
			this.tree = tree;
		}
	}

	public BaseDescriptor(ParserRuleContext ctx) {
		this.ctx = ctx;
	}

	public void setPhaseState(PhaseState state) {
		this.state = state;
	}

	public BaseDescriptor getDescriptor(ParseTree ctx) {
		return state.nodeContextMap.get(ctx);
	}
	
	@Override
	public Value process(String property) {
		return process();
	}

	@Override
	public String toString() {
		String strValue = value != null ? value.basis : "<Null Value>";
		if (collectComments) {
			return commentLeft + strValue + SP + commentRight;
		} else {
			return strValue;
		}
	}


	// //////////////////// Symbol Table Helpers ///////////////////////////

	protected String vName = "";
	protected Symbol sym = null;

	public Symbol findVarByName(String name) {
		return state.symTable.currentScope().resolve(name);
	}

	public boolean inCurrentScope(Symbol sym) {
		return state.symTable.currentScope().genId == sym.genId();
	}

	public Value getVarValue(String name) {
		Symbol sym = findVarByName(name);
		if (sym != null) {
			value = sym.getDescriptor().value;
		} else {
			value = Value.INVALID;
		}
		return value;
	}

	public void setVarValue(Value value) {
		if (sym != null) {
			sym.getDescriptor().value = value;
			this.value = value;
		} else {
			value = Value.INVALID;
		}
	}

	// ///////////////////// Parse Tree Helpers ////////////////////////////

	public List<ParseTree> getContextElements(ParserRuleContext ctx) {
		return ctx.children;
	}

	public ParseTree firstElement(ParserRuleContext ctx) {
		return ctx.children.get(0);
	}

	public ParseTree lastElement(ParserRuleContext ctx) {
		return ctx.children.get(ctx.children.size() - 1);
	}

	public ParseTree priorElement(ParserRuleContext ctx, ParseTree node) {
		buildElementAssociations(ctx);
		int index = indexOfElement(ctx, node);
		if (index < 1 || index >= assocElement.size()) return null;
		return assocElement.get(index - 1).tree;
	}

	public ParseTree nextElement(ParserRuleContext ctx, ParseTree node) {
		buildElementAssociations(ctx);
		int index = indexOfElement(ctx, node);
		if (index < 0 || index > assocElement.size() - 2) return null;
		return assocElement.get(index + 1).tree;
	}

	public ParseTree getElementAt(ParserRuleContext ctx, int index) {
		buildElementAssociations(ctx);
		if (index < 0 || index > assocElement.size() - 1) return null;
		return assocElement.get(index).tree;
	}

	public int indexOfElement(ParserRuleContext ctx, ParseTree node) {
		buildElementAssociations(ctx);
		int index = node.getSourceInterval().a;
		for (int idx = 0; idx < assocElement.size(); idx++) {
			ElementAssoc e = assocElement.get(idx);
			if (e.index == index) {
				return idx;
			}
		}
		return -1;
	}

	public void buildElementAssociations(ParserRuleContext ctx) {
		if (assocElement == null) {
			assocElement = new ArrayList<>();
			for (ParseTree node : ctx.children) {
				if (node instanceof ParserRuleContext) {
					Token t = ((ParserRuleContext) node).getStart();
					assocElement.add(new ElementAssoc(StmtType.RULE, t, node));
				} else if (node instanceof TerminalNodeImpl) {
					Token t = ((TerminalNodeImpl) node).getSymbol();
					if (node instanceof ErrorNodeImpl) {
						assocElement.add(new ElementAssoc(StmtType.ERROR, t, node));
					} else {
						assocElement.add(new ElementAssoc(StmtType.TERMINAL, t, node));
					}
				} else {
					Log.warn(this, "Unexpected node type skipped: " + node.getClass().getName());
				}
			}
		}
	}
}
>>

DescriptorClass(packageName, grammarName, genName) ::= <<
package %packageName%.converter.descriptors;

import %packageName%.converter.BaseDescriptor;
import %packageName%.converter.Value;
import %packageName%.parser.gen.%grammarName%Parser.%genName%Context;

public class %genName%Descriptor extends BaseDescriptor {

	public %genName%Descriptor(%genName%Context ctx) {
		super(ctx);
	}

	@Override
	public void initialize() {
				value = Value.FALSE;
	}

	@Override
	public Value process() {
		if (!resolved) {
			resolved = true;
		}
		return Value.TRUE;
	}

private %genName%Context context() {
		return (%genName%Context) ctx;
	}
}
>>

ValueClass(packageName) ::= <<
package %packageName%.converter;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import %packageName%.types.Op;
import %packageName%.util.Strings;

public class Value {

	private static final Pattern pattern = Pattern.compile("^\\\s*([+-]?[0-9]*[.]?[0-9]+)\\\s*(\\\w*)\\\s*$");

	public static final Value EMPTY = new Value("", "", true);
	public static final Value TRUE = new Value(1, "", true);
	public static final Value FALSE = new Value(0, "", true);
	public static final Value INVALID = new Value(0, "", false);

	public final String asString;
	public final String basis;
	public final String unit;
	public final boolean numeric;
	public final boolean valid;

	public Value(String value) {
		if (value == null) value = "";
		this.asString = value;
		Matcher m = pattern.matcher(value);
		if (m.matches()) {
			this.basis = m.group(1);
			this.unit = m.group(2);
			this.numeric = Strings.numeric(this.asString);
		} else {
			this.basis = value;
			this.unit = "";
			this.numeric = false;
		}
		valid = true;
	}

	public Value(double number, String unit, boolean valid) {
		this.asString = String.valueOf(number) + " " + unit;
		this.basis = String.valueOf(number);
		this.unit = unit;
		this.numeric = true;
		this.valid = valid;
	}

	public Value(String value, String unit, boolean valid) {
		this.asString = value + " " + unit;
		this.basis = value;
		this.unit = unit;
		this.numeric = Strings.numeric(this.asString);
		this.valid = valid;
	}

	public Value add(Value o) {
		if (comparable(o)) {
			String u = unit.equals("") ? o.unit : unit;
			if (numeric) {
				return new Value(num() + o.num(), u, true);
			} else {
				return new Value(basis + o.basis, u, true);
			}
		}
		return new Value(basis, unit, false);
	}

	public Value sub(Value o) {
		if (comparable(o)) {
			String u = unit.equals("") ? o.unit : unit;
			if (numeric) {
				return new Value(num() - o.num(), u, true);
			} else {
				return new Value(removeLast(basis, o.basis), u, true);
			}
		}
		return new Value(basis, unit, false);
	}

	public Value mult(Value o) {
		if (comparable(o) && numeric) {
			return new Value(num() * o.num(), unit, true);
		} else if (comparableMixed(o)) {
			int rep = Double.valueOf(numeric ? num() : o.num()).intValue();
			String n = numeric ? o.basis : basis;
			StringBuilder sb = new StringBuilder(n);
			for (int cnt = 0; cnt < rep - 1; cnt++) {
				sb.append(n);
			}
			String u = unit.equals("") ? o.unit : unit;
			return new Value(sb.toString(), u, true);
		}
		return new Value(basis + o.basis, unit, false);
	}

	public Value div(Value o) {
		if (comparable(o) && numeric) {
			if (o.num() != 0) {
				return new Value(num() / o.num(), unit, true);
			} else {
				return new Value(0, unit, false);
			}
		} else if (comparableMixed(o) && o.numeric) { // an int divisor of segments
			int rep = Double.valueOf(o.num()).intValue();
			String[] v = asString.split("[,\\\. ]");
			rep = v.length / rep;
			StringBuilder sb = new StringBuilder();
			for (int cnt = 0; cnt < rep; cnt++) {
				sb.append(v[cnt]);
			}
			return new Value(sb.toString(), unit, true);
		}
		return new Value(basis, unit, false);
	}

	public Value compute(Op op, Value o) {
		switch (op) {
			case EQ:
				return o; // assignment
			case EQV:
			case NEQ:
			case LT:
			case LTE:
			case GT:
			case GTE:
				return compare(op, o);
			case PLUS:
				return add(o);
			case MINUS:
				return sub(o);
			case MULT:
				return mult(o);
			case DIV:
				return div(o);
			default:
				return INVALID;
		}
	}

	public Value compare(Op op, Value o) {
		if (comparable(o) && numeric) {
			switch (op) {
				case EQV:
					return num() == o.num() ? TRUE : FALSE;
				case NEQ:
					return num() != o.num() ? TRUE : FALSE;
				case GT:
					return num() > o.num() ? TRUE : FALSE;
				case GTE:
					return num() >= o.num() ? TRUE : FALSE;
				case LT:
					return num() < o.num() ? TRUE : FALSE;
				case LTE:
					return num() <= o.num() ? TRUE : FALSE;
				default:
					return INVALID;
			}
		}
		if (comparableStrings(o)) {
			switch (op) {
				case EQV:
					return basis.compareTo(o.basis) == 0 ? TRUE : FALSE;
				case NEQ:
					return basis.compareTo(o.basis) != 0 ? TRUE : FALSE;
				case GT:
					return basis.compareTo(o.basis) > 0 ? TRUE : FALSE;
				case GTE:
					return basis.compareTo(o.basis) >= 0 ? TRUE : FALSE;
				case LT:
					return basis.compareTo(o.basis) < 0 ? TRUE : FALSE;
				case LTE:
					return basis.compareTo(o.basis) <= 0 ? TRUE : FALSE;
				default:
					return INVALID;
			}
		}
		return INVALID;
	}

	public double num() {
		if (valid && numeric) {
			return Double.valueOf(basis).doubleValue();
		}
		return 0;
	}

	public boolean comparable(Value o) {
		if (valid && o.valid
				&& (o.unit.equals(unit)
						|| o.unit.equals("")
						|| unit.equals(""))
				&& o.numeric == numeric) return true;
		return false;
	}

	// ignore numeric and units, treat as strings
	public boolean comparableStrings(Value o) {
		if (valid && o.valid) return true;
		return false;
	}

	// one numeric and the other not
	public boolean comparableMixed(Value o) {
		if (valid && o.valid
				&& (o.unit.equals(unit)
						|| o.unit.equals("")
						|| unit.equals(""))
				&& o.numeric != numeric) return true;
		return false;
	}

	private String removeLast(String value, String obj) {
		int idx = value.lastIndexOf(obj);
		if (idx == -1) return value;
		StringBuilder sb = new StringBuilder(value);
		sb.delete(idx, idx + obj.length());
		return sb.toString().trim();
	}
}
>>
